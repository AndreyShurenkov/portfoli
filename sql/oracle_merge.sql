/**************************
  Код для Oracle
***************************/
DROP TABLE agrmnt;
DROP TABLE agrmnt_res;

CREATE TABLE agrmnt (id NUMBER GENERATED BY DEFAULT AS IDENTITY,
					 agrmnt varchar2(100),
					 period DATE,
				 	 agrmnt_sum NUMBER,
				 	 type_operation char(1),
				 	 load_date date DEFAULT sysdate,
				 	 type_dml char(1) DEFAULT 'I')
	   PARTITION BY RANGE (agrmnt) (PARTITION agrmnt_prt VALUES LESS THAN (MAXVALUE));
CREATE UNIQUE INDEX idx_agrmnt_01 ON agrmnt (id);

-- Генерируем данные
BEGIN
 DELETE agrmnt;
 -- Пишем начисления
 FOR agr IN (SELECT '001/01/'||dbms_random.string('U',9) agrmnt, round(dbms_random.value(1000,2000)) agrmnt_sum, 'A' type_operation FROM dual CONNECT BY LEVEL <= 2000)
 LOOP
  FOR pr IN (SELECT ADD_MONTHS(trunc(sysdate,'yyyy'),LEVEL-1) period FROM dual CONNECT BY 0+LEVEL < 121)
  LOOP
	INSERT INTO agrmnt (agrmnt, period, agrmnt_sum, type_operation) VALUES (agr.agrmnt, pr.period, agr.agrmnt_sum, agr.type_operation);  	
  END LOOP;
 END LOOP;
 
 -- Пишем оплаты, делаем так что может образоваться по итогу оплат либо перебор либо недобор
 FOR agr IN (SELECT agrmnt, period+dbms_random.value(1,20) period, round(dbms_random.value(agrmnt_sum-100,agrmnt_sum+100)) agrmnt_sum, 'P' type_operation  
  			   FROM agrmnt)
 LOOP
  INSERT INTO agrmnt (agrmnt, period, agrmnt_sum, type_operation) VALUES (agr.agrmnt, agr.period, agr.agrmnt_sum, agr.type_operation);  	
 END LOOP;
 COMMIT;
END;

-- Создаем целевую таблицу в которую будут грузиться данные
CREATE TABLE agrmnt_res AS SELECT id, agrmnt, period, agrmnt_sum, type_operation,
								  sysdate load_date,
								  CAST(NULL as DATE) AS last_seen_date, 
								  standard_hash(id||'/'||agrmnt||'/'||period||'/'||agrmnt_sum||'/'||type_operation,'SHA256') hash_diff
						     FROM agrmnt a;
CREATE INDEX idx_agrmnt_res_01 ON agrmnt_res (id, hash_diff);

-- Генерируем изменения
BEGIN
 FOR cur IN (SELECT round(dbms_random.value(1,cnt)) id,
 					round(dbms_random.value(1000,2000)) agrmnt_sum_a,
 					round(dbms_random.value(1000,2000)) agrmnt_sum_p,
 					CASE round(dbms_random.value(1,2)) WHEN 1 THEN 'U'
 													   WHEN 2 THEN 'D'
 					 END type_dml
   			   FROM dual
   			   CROSS JOIN (SELECT count(*) cnt FROM agrmnt_res) CONNECT BY LEVEL <= 20000)
 LOOP
  UPDATE agrmnt agr SET agr.agrmnt_sum = CASE WHEN type_operation = 'A' then cur.agrmnt_sum_a ELSE cur.agrmnt_sum_p END, load_date = sysdate, type_dml = cur.type_dml
   WHERE id = cur.id;
 END LOOP;
END;

SELECT type_dml, type_operation, sum(agrmnt_sum) FROM agrmnt GROUP BY type_dml, type_operation

-- Сверям источик с целевой таблицей
WITH tmp_agr AS (SELECT type_operation, sum(agrmnt_sum) agrmnt_sum
				   FROM AGRMNT a
				  WHERE a.type_dml in ('I','U')
				  GROUP BY type_operation),
	 tmp_agr_res AS (SELECT type_operation, sum(agrmnt_sum) agrmnt_res_sum
				   	   FROM AGRMNT_RES a
					  WHERE a.last_seen_date IS NULL 
					  GROUP BY type_operation)
SELECT nvl(agr.type_operation,agr_res.type_operation) type_operation, agrmnt_sum, agrmnt_res_sum
  FROM tmp_agr agr
  FULL JOIN tmp_agr_res agr_res ON (agr_res.type_operation = agr.type_operation)
  
-- Обновляем данные в целевой таблице закрывая старые записи и добавляя новые
MERGE INTO agrmnt_res agr_res
USING (WITH tmp_load_date AS (SELECT max(load_date) load_date FROM agrmnt_res), -- посмотрили когда была последняя загрузка
			tmp_source AS (SELECT id FROM agrmnt WHERE load_date > (SELECT * FROM tmp_load_date)), -- взяли все id после последней загрузки
			tmp_agrmnt AS (SELECT ta.*,
		    					  standard_hash(ta.id||'/'||ta.agrmnt||'/'||ta.period||'/'||ta.agrmnt_sum||'/'||ta.type_operation,'SHA256') hash_diff
		   				     FROM tmp_source ts
			 				 JOIN agrmnt ta ON (ts.id = ta.id)
			 			    WHERE ta.type_dml in ('I','U')), -- собрали источник
			tmp_agrmnt_res AS (SELECT ta.id id_res,
		    						  ta.hash_diff hash_diff_res
				 				 FROM tmp_source ts
				 				 JOIN agrmnt_res ta ON (ts.id = ta.id)
				 			    WHERE ta.last_seen_date IS NULL) -- собрали записи из целевой таблицы в которые засветились в источнике
	  SELECT agr.*, agr_res.*
		FROM tmp_agrmnt agr
		FULL JOIN tmp_agrmnt_res agr_res ON (agr.id = agr_res.id_res AND
 	   										 agr.hash_diff = agr_res.hash_diff_res)
	   WHERE agr.id IS NULL OR agr_res.id_res IS NULL) agr
ON (agr_res.id = agr.id_res AND
    agr_res.hash_diff = agr.hash_diff_res)
 WHEN MATCHED THEN UPDATE SET agr_res.last_seen_date = SYSDATE -- закрываем старые записи
 WHEN NOT MATCHED THEN 
 INSERT (id, agrmnt, period, agrmnt_sum, type_operation, hash_diff) VALUES (agr.id, agr.agrmnt, agr.period, agr.agrmnt_sum, agr.type_operation, agr.hash_diff);
	  
-- Сверяем еще раз	 				 
WITH tmp_agr AS (SELECT type_operation, sum(agrmnt_sum) agrmnt_sum
				   FROM AGRMNT a
				  WHERE a.type_dml in ('I','U')
				  GROUP BY type_operation),
	 tmp_agr_res AS (SELECT type_operation, sum(agrmnt_sum) agrmnt_res_sum
				   	   FROM AGRMNT_RES a
					  WHERE a.last_seen_date IS NULL 
					  GROUP BY type_operation)
SELECT nvl(agr.type_operation,agr_res.type_operation) type_operation, agrmnt_sum, agrmnt_res_sum
  FROM tmp_agr agr
  FULL JOIN tmp_agr_res agr_res ON (agr_res.type_operation = agr.type_operation);	  